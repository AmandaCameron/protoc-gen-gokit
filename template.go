package main

import (
	"text/template"
)

var fileTemplate = template.Must(template.New("file").Parse(`// Generated by protoc-gen-gokit DO NOT EDIT.
package {{.Package}}

import (
  "net/http"
  "errors"
  "strings"

  "golang.org/x/net/context"

  kithttp "github.com/go-kit/kit/transport/http"
  "github.com/go-kit/kit/endpoint"

  "github.com/AmandaCameron/protoc-gen-gokit/runtime"

{{ range $k, $pkg := .Imports }}
  . "{{ $pkg }}"{{ end }}
)

{{ range $svc := .Services }}

// MakeMux_{{$svc.GoName}} creates a server mux for the {{ $svc.GoName }} service, 
// using the passed kithttp.Server as a template for the parameters of the endpoints.
func MakeMux_{{ $svc.GoName }}(cli {{ $svc.GoName }}Client, mw endpoint.Middleware, responseEncoder kithttp.EncodeResponseFunc, error options ...kithttp.ServerOption) (http.Handler, error) {
  ret := runtime.NewMux()

{{ range $endp := $svc.Methods }}
  ret.AddEndpoint("{{ $endp.Method }}", "{{ $endp.Path }}", kithttp.NewServer(
   context.Background(), 
   mw(MakeEndpoint_{{ $svc.GoName }}_{{ $endp.GoName }}(cli)),
   Decode_{{ $svc.GoName }}_{{ $endp.GoName }},
   responseEncoder, options...)
  ){{end}}

  return ret, nil
}

{{ range $method := $svc.Methods }}
// Decode_{{ $svc.GoName }}_{{ $method.GoName }} decodes an http.Request into a {{ $method.GoInputType }}.
func Decode_{{ $svc.GoName }}_{{ $method.GoName }}(req *http.Request) (interface{}, error) {
  var ret {{ $method.GoInputType }}

  qry := req.URL.Query()
  _ = qry

{{ range $i, $field := $method.Input.Fields }}
  if val := qry.Get("{{ $field.ProtoName }}"); val != "" {
    if err := runtime.Decode(&ret.{{ $field.GoName }}, val); err != nil {
      return nil, err
    }
  }{{ end }}

  parts := strings.Split(req.URL.Path, "/")
  if len(parts) < {{ len $method.PathArgs }} {
    return nil, errors.New("Missing Parameters.")
  }

{{ range $i, $field := $method.PathArgs }}{{ if len $field.GoName }}
  if err := runtime.Decode(&ret.{{ $field.GoName}}, parts[{{ $i }}]); err != nil {
    return nil, err
  }{{ end }}{{ end }}

  return &ret, nil
}

// MakeEndpoint_{{ $svc.GoName }}_{{ $method.GoName }} creates an endpoint function for Go-kit 
// that runs the specified service / endpoint on the specified grpc endpoint.
func MakeEndpoint_{{ $svc.GoName }}_{{ $method.GoName }}(cli {{ $svc.GoName }}Client) endpoint.Endpoint {
  endp := func (ctx context.Context, inp interface{}) (interface{}, error) {
    return cli.{{ $method.GoName }}(ctx, inp.(*{{ $method.GoInputType }}))
  }

  return endp
}
{{ end }}{{ end }}`))
